<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>12-san-lie-biao | zxk&#39;s book</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="兴趣使然的备忘库">
    <link rel="preload" href="/books/assets/css/0.styles.50f3151d.css" as="style"><link rel="preload" href="/books/assets/js/app.f49d838e.js" as="script"><link rel="preload" href="/books/assets/js/2.3809c37a.js" as="script"><link rel="preload" href="/books/assets/js/79.787f9e2a.js" as="script"><link rel="prefetch" href="/books/assets/js/10.173e6f22.js"><link rel="prefetch" href="/books/assets/js/100.93149a22.js"><link rel="prefetch" href="/books/assets/js/101.4bb37a49.js"><link rel="prefetch" href="/books/assets/js/102.908f675f.js"><link rel="prefetch" href="/books/assets/js/103.b470edcb.js"><link rel="prefetch" href="/books/assets/js/104.0d96599f.js"><link rel="prefetch" href="/books/assets/js/105.46356f60.js"><link rel="prefetch" href="/books/assets/js/106.2859c731.js"><link rel="prefetch" href="/books/assets/js/107.e035252f.js"><link rel="prefetch" href="/books/assets/js/11.95675098.js"><link rel="prefetch" href="/books/assets/js/12.4f9309cc.js"><link rel="prefetch" href="/books/assets/js/13.b08c71ed.js"><link rel="prefetch" href="/books/assets/js/14.21b5c4e6.js"><link rel="prefetch" href="/books/assets/js/15.cdb568da.js"><link rel="prefetch" href="/books/assets/js/16.1f61bacf.js"><link rel="prefetch" href="/books/assets/js/17.f92c956c.js"><link rel="prefetch" href="/books/assets/js/18.80fb975c.js"><link rel="prefetch" href="/books/assets/js/19.c14ed473.js"><link rel="prefetch" href="/books/assets/js/20.3b61c71f.js"><link rel="prefetch" href="/books/assets/js/21.1d0eda6f.js"><link rel="prefetch" href="/books/assets/js/22.d111a3c4.js"><link rel="prefetch" href="/books/assets/js/23.2319e04b.js"><link rel="prefetch" href="/books/assets/js/24.fab9dc05.js"><link rel="prefetch" href="/books/assets/js/25.f48e0e3f.js"><link rel="prefetch" href="/books/assets/js/26.c7efb2c3.js"><link rel="prefetch" href="/books/assets/js/27.a9e03a40.js"><link rel="prefetch" href="/books/assets/js/28.a01a8c75.js"><link rel="prefetch" href="/books/assets/js/29.8761f141.js"><link rel="prefetch" href="/books/assets/js/3.5c52f258.js"><link rel="prefetch" href="/books/assets/js/30.e774d6db.js"><link rel="prefetch" href="/books/assets/js/31.6f4bffc0.js"><link rel="prefetch" href="/books/assets/js/32.1f62d60b.js"><link rel="prefetch" href="/books/assets/js/33.c7aea22b.js"><link rel="prefetch" href="/books/assets/js/34.01929a45.js"><link rel="prefetch" href="/books/assets/js/35.0fe51d37.js"><link rel="prefetch" href="/books/assets/js/36.957aba7b.js"><link rel="prefetch" href="/books/assets/js/37.9e255472.js"><link rel="prefetch" href="/books/assets/js/38.23731932.js"><link rel="prefetch" href="/books/assets/js/39.4005f83b.js"><link rel="prefetch" href="/books/assets/js/4.4e6e6a80.js"><link rel="prefetch" href="/books/assets/js/40.47ddf780.js"><link rel="prefetch" href="/books/assets/js/41.ffb6939e.js"><link rel="prefetch" href="/books/assets/js/42.c736916b.js"><link rel="prefetch" href="/books/assets/js/43.649267b4.js"><link rel="prefetch" href="/books/assets/js/44.604b76cd.js"><link rel="prefetch" href="/books/assets/js/45.5c045c1f.js"><link rel="prefetch" href="/books/assets/js/46.9a006676.js"><link rel="prefetch" href="/books/assets/js/47.eacd6a46.js"><link rel="prefetch" href="/books/assets/js/48.d675b621.js"><link rel="prefetch" href="/books/assets/js/49.d629c51a.js"><link rel="prefetch" href="/books/assets/js/5.714c3f84.js"><link rel="prefetch" href="/books/assets/js/50.86dfdbd8.js"><link rel="prefetch" href="/books/assets/js/51.a34aa91a.js"><link rel="prefetch" href="/books/assets/js/52.d58c2607.js"><link rel="prefetch" href="/books/assets/js/53.cf1a7467.js"><link rel="prefetch" href="/books/assets/js/54.8b5c039b.js"><link rel="prefetch" href="/books/assets/js/55.8996992c.js"><link rel="prefetch" href="/books/assets/js/56.5c37b9d7.js"><link rel="prefetch" href="/books/assets/js/57.2dcf7224.js"><link rel="prefetch" href="/books/assets/js/58.752334c2.js"><link rel="prefetch" href="/books/assets/js/59.50ef5988.js"><link rel="prefetch" href="/books/assets/js/6.37036b9d.js"><link rel="prefetch" href="/books/assets/js/60.49c8ae18.js"><link rel="prefetch" href="/books/assets/js/61.82bfc8f5.js"><link rel="prefetch" href="/books/assets/js/62.e2684aca.js"><link rel="prefetch" href="/books/assets/js/63.ba81314a.js"><link rel="prefetch" href="/books/assets/js/64.4a9e1f94.js"><link rel="prefetch" href="/books/assets/js/65.80f33626.js"><link rel="prefetch" href="/books/assets/js/66.c2a44e6c.js"><link rel="prefetch" href="/books/assets/js/67.612f6ed4.js"><link rel="prefetch" href="/books/assets/js/68.e8d5bee8.js"><link rel="prefetch" href="/books/assets/js/69.73801a44.js"><link rel="prefetch" href="/books/assets/js/7.f89c49dc.js"><link rel="prefetch" href="/books/assets/js/70.dec2f1de.js"><link rel="prefetch" href="/books/assets/js/71.a3208f56.js"><link rel="prefetch" href="/books/assets/js/72.7460a44c.js"><link rel="prefetch" href="/books/assets/js/73.1bb45c74.js"><link rel="prefetch" href="/books/assets/js/74.8f0aaef8.js"><link rel="prefetch" href="/books/assets/js/75.d6798103.js"><link rel="prefetch" href="/books/assets/js/76.617f9599.js"><link rel="prefetch" href="/books/assets/js/77.1580edd0.js"><link rel="prefetch" href="/books/assets/js/78.6bd19f58.js"><link rel="prefetch" href="/books/assets/js/8.d4e84bb7.js"><link rel="prefetch" href="/books/assets/js/80.a3d78ca7.js"><link rel="prefetch" href="/books/assets/js/81.5d50eeb4.js"><link rel="prefetch" href="/books/assets/js/82.2b8ed68b.js"><link rel="prefetch" href="/books/assets/js/83.0ce7a910.js"><link rel="prefetch" href="/books/assets/js/84.0d881df0.js"><link rel="prefetch" href="/books/assets/js/85.2f8767ef.js"><link rel="prefetch" href="/books/assets/js/86.710b8f60.js"><link rel="prefetch" href="/books/assets/js/87.5adfe8bf.js"><link rel="prefetch" href="/books/assets/js/88.11bbc9c5.js"><link rel="prefetch" href="/books/assets/js/89.9c9af733.js"><link rel="prefetch" href="/books/assets/js/9.57493b19.js"><link rel="prefetch" href="/books/assets/js/90.b214aa26.js"><link rel="prefetch" href="/books/assets/js/91.4d8f5e69.js"><link rel="prefetch" href="/books/assets/js/92.4acf0897.js"><link rel="prefetch" href="/books/assets/js/93.d04fb839.js"><link rel="prefetch" href="/books/assets/js/94.25880506.js"><link rel="prefetch" href="/books/assets/js/95.354b10df.js"><link rel="prefetch" href="/books/assets/js/96.cd05ef30.js"><link rel="prefetch" href="/books/assets/js/97.180a5a94.js"><link rel="prefetch" href="/books/assets/js/98.88a70f24.js"><link rel="prefetch" href="/books/assets/js/99.d52ebb90.js">
    <link rel="stylesheet" href="/books/assets/css/0.styles.50f3151d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/books/" class="home-link router-link-active"><img src="/books/Avatar.jpg" alt="zxk's book" class="logo"> <span class="site-name can-hide">zxk's book</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/books/nav.01.big-data/" class="nav-link">
  Big Data
</a></div><div class="nav-item"><a href="/books/nav.02.linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/books/nav.03.program-language/" class="nav-link">
  Program Language
</a></div><div class="nav-item"><a href="/books/nav.04.algorithm/" class="nav-link">
  Algorithm
</a></div><div class="nav-item"><a href="/books/nav.05.design-pattern/" class="nav-link">
  Design Pattern
</a></div><div class="nav-item"><a href="/books/nav.06.database/" class="nav-link">
  Database
</a></div><div class="nav-item"><a href="/books/nav.07.software/" class="nav-link">
  Software
</a></div><div class="nav-item"><a href="/books/" class="nav-link">
  Home
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/books/nav.01.big-data/" class="nav-link">
  Big Data
</a></div><div class="nav-item"><a href="/books/nav.02.linux/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/books/nav.03.program-language/" class="nav-link">
  Program Language
</a></div><div class="nav-item"><a href="/books/nav.04.algorithm/" class="nav-link">
  Algorithm
</a></div><div class="nav-item"><a href="/books/nav.05.design-pattern/" class="nav-link">
  Design Pattern
</a></div><div class="nav-item"><a href="/books/nav.06.database/" class="nav-link">
  Database
</a></div><div class="nav-item"><a href="/books/nav.07.software/" class="nav-link">
  Software
</a></div><div class="nav-item"><a href="/books/" class="nav-link">
  Home
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>数据结构与算法（专栏学习）</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/books/pages/09d402/" class="sidebar-link">01-shi-jian-fu-za-du</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/09d402/#为什么需要复杂度分析？" class="sidebar-link">为什么需要复杂度分析？</a></li><li class="sidebar-sub-header"><a href="/books/pages/09d402/#大-o-复杂度表示法" class="sidebar-link">大 O 复杂度表示法</a></li><li class="sidebar-sub-header"><a href="/books/pages/09d402/#时间复杂度分析" class="sidebar-link">时间复杂度分析</a></li><li class="sidebar-sub-header"><a href="/books/pages/09d402/#几种常见的时间复杂度" class="sidebar-link">几种常见的时间复杂度</a></li><li class="sidebar-sub-header"><a href="/books/pages/09d402/#空间复杂度分析" class="sidebar-link">空间复杂度分析</a></li><li class="sidebar-sub-header"><a href="/books/pages/09d402/#时间复杂度进阶" class="sidebar-link">时间复杂度进阶</a></li><li class="sidebar-sub-header"><a href="/books/pages/09d402/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/books/pages/5c5c08/" class="sidebar-link">02-shu-zu</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/5c5c08/#如何实现随机访问？" class="sidebar-link">如何实现随机访问？</a></li><li class="sidebar-sub-header"><a href="/books/pages/5c5c08/#低效的-插入-和-删除" class="sidebar-link">低效的“插入”和“删除”</a></li><li class="sidebar-sub-header"><a href="/books/pages/5c5c08/#警惕数组的访问越界问题" class="sidebar-link">警惕数组的访问越界问题</a></li><li class="sidebar-sub-header"><a href="/books/pages/5c5c08/#容器能否完全替代数组？" class="sidebar-link">容器能否完全替代数组？</a></li><li class="sidebar-sub-header"><a href="/books/pages/5c5c08/#思考" class="sidebar-link">思考</a></li></ul></li><li><a href="/books/pages/6f5a01/" class="sidebar-link">03-lian-biao</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/6f5a01/#_1-几种链表结构" class="sidebar-link">1. 几种链表结构</a></li><li class="sidebar-sub-header"><a href="/books/pages/6f5a01/#_1-4-链表-vs-数组性能" class="sidebar-link">1.4 链表 VS 数组性能</a></li><li class="sidebar-sub-header"><a href="/books/pages/6f5a01/#_2-基于链表实现lru算法" class="sidebar-link">2. 基于链表实现LRU算法</a></li><li class="sidebar-sub-header"><a href="/books/pages/6f5a01/#_3-编写链表的几点技巧" class="sidebar-link">3. 编写链表的几点技巧</a></li><li class="sidebar-sub-header"><a href="/books/pages/6f5a01/#_2-警惕指针丢失和内存泄漏" class="sidebar-link">2. 警惕指针丢失和内存泄漏</a></li><li class="sidebar-sub-header"><a href="/books/pages/6f5a01/#思考" class="sidebar-link">思考</a></li></ul></li><li><a href="/books/pages/33f199/" class="sidebar-link">04-zhan</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/33f199/#_1-如何实现栈？" class="sidebar-link">1. 如何实现栈？</a></li><li class="sidebar-sub-header"><a href="/books/pages/33f199/#_1-2-链式栈" class="sidebar-link">1.2 链式栈</a></li><li class="sidebar-sub-header"><a href="/books/pages/33f199/#_2-栈在函数调用中的应用" class="sidebar-link">2. 栈在函数调用中的应用</a></li><li class="sidebar-sub-header"><a href="/books/pages/33f199/#_3-栈在表达式求值中的应用" class="sidebar-link">3. 栈在表达式求值中的应用</a></li><li class="sidebar-sub-header"><a href="/books/pages/33f199/#_4-总结" class="sidebar-link">4. 总结</a></li></ul></li><li><a href="/books/pages/82b72f/" class="sidebar-link">05-dui-lie</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/82b72f/#_1-顺序队列和链式队列" class="sidebar-link">1. 顺序队列和链式队列</a></li><li class="sidebar-sub-header"><a href="/books/pages/82b72f/#_2-循环队列" class="sidebar-link">2. 循环队列</a></li><li class="sidebar-sub-header"><a href="/books/pages/82b72f/#_3-阻塞队列和并发队列" class="sidebar-link">3. 阻塞队列和并发队列</a></li><li class="sidebar-sub-header"><a href="/books/pages/82b72f/#_4-思考" class="sidebar-link">4. 思考</a></li></ul></li><li><a href="/books/pages/5a8205/" class="sidebar-link">06-di-gui</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/5a8205/#_1-递归代码示例" class="sidebar-link">1. 递归代码示例</a></li><li class="sidebar-sub-header"><a href="/books/pages/5a8205/#_2-递归导致堆栈溢出" class="sidebar-link">2. 递归导致堆栈溢出</a></li><li class="sidebar-sub-header"><a href="/books/pages/5a8205/#_3-递归要警惕重复计算" class="sidebar-link">3. 递归要警惕重复计算</a></li><li class="sidebar-sub-header"><a href="/books/pages/5a8205/#_4-思考" class="sidebar-link">4. 思考</a></li></ul></li><li><a href="/books/pages/fcbb91/" class="sidebar-link">07-pai-xu</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/fcbb91/#_1-冒泡、插入、选择排序" class="sidebar-link">1. 冒泡、插入、选择排序</a></li><li class="sidebar-sub-header"><a href="/books/pages/fcbb91/#_2-快速、归并排序" class="sidebar-link">2. 快速、归并排序</a></li></ul></li><li><a href="/books/pages/4d335f/" class="sidebar-link">08-xian-xing-pai-xu</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/4d335f/#_1-桶排序（bucket-sort）" class="sidebar-link">1. 桶排序（Bucket Sort）</a></li><li class="sidebar-sub-header"><a href="/books/pages/4d335f/#_2-计数排序（counting-sort）" class="sidebar-link">2. 计数排序（Counting sort）</a></li><li class="sidebar-sub-header"><a href="/books/pages/4d335f/#_3-基数排序（radix-sort）" class="sidebar-link">3. 基数排序（Radix sort）</a></li></ul></li><li><a href="/books/pages/81d135/" class="sidebar-link">09-pai-xu-you-hua</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/81d135/#_1-如何优化快速排序" class="sidebar-link">1. 如何优化快速排序</a></li><li class="sidebar-sub-header"><a href="/books/pages/81d135/#_2-举例分析排序函数" class="sidebar-link">2. 举例分析排序函数</a></li></ul></li><li><a href="/books/pages/9f635b/" class="sidebar-link">10-er-fen-cha-zhao</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/9f635b/#_1-介绍" class="sidebar-link">1. 介绍</a></li><li class="sidebar-sub-header"><a href="/books/pages/9f635b/#_2-二分查找的局限性" class="sidebar-link">2. 二分查找的局限性</a></li><li class="sidebar-sub-header"><a href="/books/pages/9f635b/#_3-二分查找变形" class="sidebar-link">3. 二分查找变形</a></li><li class="sidebar-sub-header"><a href="/books/pages/9f635b/#_4-思考题" class="sidebar-link">4. 思考题</a></li><li class="sidebar-sub-header"><a href="/books/pages/9f635b/#_5-总结" class="sidebar-link">5. 总结</a></li></ul></li><li><a href="/books/pages/62cbc8/" class="sidebar-link">11-tiao-biao</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/62cbc8/#_1-时间复杂度与空间复杂度" class="sidebar-link">1. 时间复杂度与空间复杂度</a></li><li class="sidebar-sub-header"><a href="/books/pages/62cbc8/#_2-动态插入与删除" class="sidebar-link">2. 动态插入与删除</a></li><li class="sidebar-sub-header"><a href="/books/pages/62cbc8/#_3-索引动态更新" class="sidebar-link">3. 索引动态更新</a></li><li class="sidebar-sub-header"><a href="/books/pages/62cbc8/#_4-思考" class="sidebar-link">4. 思考</a></li></ul></li><li><a href="/books/pages/046d2a/" aria-current="page" class="active sidebar-link">12-san-lie-biao</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_1-散列函数" class="sidebar-link">1. 散列函数</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_2-散列冲突" class="sidebar-link">2. 散列冲突</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_3-装载因子" class="sidebar-link">3. 装载因子</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_4-散列表存在的问题" class="sidebar-link">4. 散列表存在的问题</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_5-开放寻址法-vs-链表法" class="sidebar-link">5. 开放寻址法 VS 链表法</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_6-java中hashmap分析" class="sidebar-link">6. Java中HashMap分析</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_7-散列表＆链表" class="sidebar-link">7. 散列表＆链表</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_8-redis有序集合" class="sidebar-link">8. Redis有序集合</a></li><li class="sidebar-sub-header"><a href="/books/pages/046d2a/#_9-思考" class="sidebar-link">9. 思考</a></li></ul></li><li><a href="/books/pages/29a5b1/" class="sidebar-link">13-ha-xi-suan-fa</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#_1-安全加密" class="sidebar-link">1. 安全加密</a></li><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#_2-唯一标示" class="sidebar-link">2. 唯一标示</a></li><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#_3-数据校验" class="sidebar-link">3. 数据校验</a></li><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#_4-散列函数" class="sidebar-link">4. 散列函数</a></li><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#_5-负载均衡" class="sidebar-link">5. 负载均衡</a></li><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#_6-数据分片" class="sidebar-link">6. 数据分片</a></li><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#_7-分布式存储" class="sidebar-link">7. 分布式存储</a></li><li class="sidebar-sub-header"><a href="/books/pages/29a5b1/#思考" class="sidebar-link">思考</a></li></ul></li><li><a href="/books/pages/848326/" class="sidebar-link">14-er-cha-shu</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/848326/#_1-二叉树" class="sidebar-link">1. 二叉树</a></li><li class="sidebar-sub-header"><a href="/books/pages/848326/#_2-二叉查找树（binary-search-tree）" class="sidebar-link">2. 二叉查找树（Binary Search Tree）</a></li><li class="sidebar-sub-header"><a href="/books/pages/848326/#思考" class="sidebar-link">思考</a></li></ul></li><li><a href="/books/pages/e58704/" class="sidebar-link">15-hong-hei-shu</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/e58704/#_1-红黑树（r-b-tree）的定义" class="sidebar-link">1. 红黑树（R-B Tree）的定义</a></li><li class="sidebar-sub-header"><a href="/books/pages/e58704/#_2-平衡性分析" class="sidebar-link">2. 平衡性分析</a></li><li class="sidebar-sub-header"><a href="/books/pages/e58704/#_3-红黑树的插入" class="sidebar-link">3. 红黑树的插入</a></li><li class="sidebar-sub-header"><a href="/books/pages/e58704/#_4-红黑树的删除" class="sidebar-link">4. 红黑树的删除</a></li><li class="sidebar-sub-header"><a href="/books/pages/e58704/#思考" class="sidebar-link">思考</a></li></ul></li><li><a href="/books/pages/d7b69f/" class="sidebar-link">16-di-gui-shu</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/books/pages/d7b69f/#_1-递归树与时间复杂度分析" class="sidebar-link">1. 递归树与时间复杂度分析</a></li><li class="sidebar-sub-header"><a href="/books/pages/d7b69f/#_2-分析快速排序的时间复杂度" class="sidebar-link">2. 分析快速排序的时间复杂度</a></li><li class="sidebar-sub-header"><a href="/books/pages/d7b69f/#_3-分析斐波那契数列的时间复杂度" class="sidebar-link">3. 分析斐波那契数列的时间复杂度</a></li><li class="sidebar-sub-header"><a href="/books/pages/d7b69f/#_4-分析全排列的时间复杂度" class="sidebar-link">4. 分析全排列的时间复杂度</a></li><li class="sidebar-sub-header"><a href="/books/pages/d7b69f/#_5-思考" class="sidebar-link">5. 思考</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_12-散列表"><a href="#_12-散列表" class="header-anchor">#</a> 12 | 散列表</h1> <p><strong>散列表</strong>（Hash Table），是在数组的基础上，通过hash算法取得对象的hash值作为数组下标，将其存储到数组指定位置。当需要再访问对象时，再根据对象的hash值即可借助数组随机访问的特性来快速定位对象位置。</p> <h2 id="_1-散列函数"><a href="#_1-散列函数" class="header-anchor">#</a> 1. 散列函数</h2> <p>散列函数，是散列表中的核心，它是一个函数，能够将对讲转化为一个hash值。假设对象的hash值为key，那么可以表示为 <code>key=hash(obj)</code> ，伪代码如下：</p> <div class="language-vim line-numbers-mode"><pre class="language-vim"><code>int <span class="token function">hash</span><span class="token punctuation">(</span>String <span class="token builtin">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">/</span><span class="token operator">/</span> 获取后两位字符
  string lastTwoChars <span class="token operator">=</span> <span class="token builtin">key</span><span class="token operator">.</span><span class="token function">substr</span><span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">/</span><span class="token operator">/</span> 将后两位字符转换为整数
  int hashValue <span class="token operator">=</span> convert lastTwoChas <span class="token keyword">to</span> int<span class="token operator">-</span>type<span class="token punctuation">;</span>
  <span class="token keyword">return</span> hashValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如何设计散列函数对于散列表来说至关重要，散列函数有三点设计要求：</p> <ol><li>散列函数得到的hash值必须是一个正整数，因为数组的下标只能是0以及正整数。</li> <li>如果 obj1=obj2，那么 hash(obj1)=hash(obj2)。</li> <li>如果 obj1!=obj2，那么 hash(obj1)!=hash(obj2)。</li></ol> <p>然而在实际情况中，第三点是做不到的，即使像 <a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener noreferrer">MD5<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="noopener noreferrer">SHA<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97" target="_blank" rel="noopener noreferrer">CRC<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 等哈希算法，也无法完全做到避免这种<strong>散列冲突</strong>。并且，在数组空间有限的情况下，冲突的概率会更大。</p> <h2 id="_2-散列冲突"><a href="#_2-散列冲突" class="header-anchor">#</a> 2. 散列冲突</h2> <p>散列冲突无法避免，我们通常可以采用两种方法来处理散列冲突：<strong>开放寻址法</strong>（open addressing）和<strong>链表法</strong>（chaining）</p> <h3 id="_2-1-开放寻址法"><a href="#_2-1-开放寻址法" class="header-anchor">#</a> 2.1 开放寻址法</h3> <p>开放寻址法的思想是，当探测到的位置已经存在数据时，则探寻另一个空闲的位置，最简单的探寻方法是<strong>线性探测</strong>（Linear Probing）。</p> <p>线性探测的做法是，当探测到一个位置已经有数据的时候，则继续往后探测，直到找到一个空间的位置，如下：</p> <p><img src="https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg" alt="线性探测"></p> <p>橙色表示已经存储了数据，当hash值探测到的位置已经有元素的时候，则继续往下找。</p> <p>这种方法虽然简单，但是在更新、删除数据方面会有较多问题，比如当我们查找一个数据的时候，若有散列冲突，线性探测过程中若有一个数据被删除了，那么按照我们原本的查找算法， 遇到空闲的位置就停止不动了，从而导致在后面存在的数据，查找不到。</p> <p>解决方法是不删除数据，而是将其标记为deleted，在线性查找的时候遇到deleted不停止，而是继续往下探测：</p> <p><img src="https://static001.geekbang.org/resource/image/fe/1d/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg" alt=""></p> <p>线性探测存在的问题，就是在数据空间越来越少的时候，我们需要探测的位置越来越多，最终导致需要遍历整个数组，从O(1)的时间复杂度退化到了O(n)。</p> <p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）。</p> <p>二次探测，就是在线性探测的基础上进行改造的，若线性探测是hash(obj)+0，hash(obj)+1，hash(obj)+2……那么二次探测就是hash(obj)+0，hash(obj)+1^2， hash(obj)+2^2……也就是在线性探测步长的基础上进行开方。</p> <p>双重散列，就是使用一组散列函数 hash1(obj)，hash2(obj)，hash3(obj) ，假如第一个散列函数造成了冲突，那么我们再使用第二个散列函数，直到找到空闲位置。</p> <h3 id="_2-2-链表法"><a href="#_2-2-链表法" class="header-anchor">#</a> 2.2 链表法</h3> <p>链表法是一种更加常用的散列冲突解决办法（也是Java中HashMap采用的做法），当发生散列冲突时，在对应的桶或者说是槽上，将冲突的元素组织成一个链表。</p> <p><img src="https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt="链表法"></p> <p>当我们需要插入的时候，只需要根据散列值访问对应的位置并追加进去即可，所以插入的时间复杂度是O(1)。查找 元素的时间复杂度取决于链表的长度 k ，所以当数据分布较均匀的时候，理论上查找的时间复杂度为 n/m ，n为数据个数，m为散列表的桶个数。</p> <h2 id="_3-装载因子"><a href="#_3-装载因子" class="header-anchor">#</a> 3. 装载因子</h2> <p>不管采用哪种方法，<strong>当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高</strong>。为了尽可能保证散列表的操作效率，一般情况下，<strong>我们会尽可能保证散列表中有一定比例的空闲槽位</strong>。我们用装载因子（load factor）来表示空位的多少。</p> <p>装载因子的计算公式是：</p> <blockquote><p>散列表的装载因子=填入表中的元素个数/散列表的长度</p></blockquote> <p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。当数据个数与散列表桶个数达到装载因子的时候，通常为了性能，我们会对散列表进行扩容。</p> <h2 id="_4-散列表存在的问题"><a href="#_4-散列表存在的问题" class="header-anchor">#</a> 4. 散列表存在的问题</h2> <p>散列表虽然理论上各个操作都很高效，但在散列冲突严重的时候性能会大大下降，散列攻击就是通过一组精心设计的值，一直产生散列冲突，从而达到让服务器高负荷拒绝服务的目的。</p> <p>散列表有两点因素直接决定了一个散列表设计的好坏：散列函数和装载因子。</p> <h3 id="_4-1-散列函数的设计"><a href="#_4-1-散列函数的设计" class="header-anchor">#</a> 4.1 散列函数的设计</h3> <p>一个好的散列函数，能够很大程度上的减少散列碰撞的概率，从而提高散列表的性能，但同时又不能设计的太复杂，若过于复杂导致求散列值的性能下降，也就影响了散列表的性能。</p> <p>以手机号码为例子，当我们对手机号求散列值的时候，我们往往可以忽略前面几位，因为很多手机号前面几位都是相同的，但到后面几个尾数往往就不尽相同了，以尾数来求散列值相比前面几位能够降低散列碰撞的概率。</p> <p>再以单词举例，我们可以对字母进行进位相加操作，再对散列表长度进行求余从而得到散列值：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">hash</span><span class="token punctuation">(</span><span class="token string">&quot;nice&quot;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">&quot;n&quot;</span> <span class="token operator">-</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">26</span><span class="token operator">*</span><span class="token number">26</span><span class="token operator">*</span><span class="token number">26</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">&quot;i&quot;</span> <span class="token operator">-</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">26</span><span class="token operator">*</span><span class="token number">26</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span> <span class="token operator">-</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">26</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">&quot;e&quot;</span><span class="token operator">-</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">78978</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，这些只要了解，不需要全都掌握。</p> <h3 id="_4-2-装载因子的大小"><a href="#_4-2-装载因子的大小" class="header-anchor">#</a> 4.2 装载因子的大小</h3> <p>装载因子决定了散列表在内存空间与效率上的一个取舍，过大的装载因子会导致散列碰撞概率增大，过小又会导致频繁扩容浪费内存空间。</p> <p>当装载因子过大时，比如0.8，我们就需要对散列表进行动态扩容，否则会导致散列碰撞严重从而大大降低性能。假如散列表容量扩大一倍，那么负载因子就变成了0.4，但同时也需要进行数据迁移，并且数据位置往往也会发生变化，如下：</p> <p><img src="https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg" alt=""></p> <p>也就是在某次插入时会发生扩容，时间复杂度为 O(n) ，但根据均摊算法，插入的操作的平均时间复杂度为 O(1) 。</p> <h3 id="_4-3-避免低效扩容"><a href="#_4-3-避免低效扩容" class="header-anchor">#</a> 4.3 避免低效扩容</h3> <p>按照前面提到的，一旦某个时刻发生了扩容，由于需要进行一个 O(n) 的数据迁移操作，那么在那个时间点性能就会大大降低，从而影响使用。这里讨论一些思路可以尽可能优化这些操作。</p> <p>当发生扩容时，我们申请一个新的数组，但并不立刻将旧数组的数据迁移到新数组，而是在每次有新的数据插入到新数组的时候，也跟着将旧数组的一个数据插入到新数组，这样一来就可以将扩容操作的代价均摊到多次操作中。</p> <p>至于数据查询的话，可以先到旧数组进行查询，查询不到再到新数组中。</p> <p><img src="https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg" alt=""></p> <h2 id="_5-开放寻址法-vs-链表法"><a href="#_5-开放寻址法-vs-链表法" class="header-anchor">#</a> 5. 开放寻址法 VS 链表法</h2> <p>前面提到了两种解决散列冲突的方法：开放寻址法、链表法。</p> <p>开放寻址法实现简单，而且都是存储在数组中，可以利用CPU缓存，不需要额外的链表空间，指针等，序列化起来也较为简单，但是在进行删除操作的时候较为麻烦，需要特殊的操作，并且由于都存在一个数组中，比起链表法发生冲突的概率更高。因此综合来说，<strong>开放寻址法更适合数据量以及装载因子都比较小的场景</strong>，比如Java中ThreadLocalMap就是采用开放寻址法。</p> <p>链表法使用了额外的链表空间来存储同个数组位置的元素，因此可以大大减少散列碰撞的概率，对负载因子大小的容忍度更高，但由于使用了链表，对内存空间的消耗也会增多（若存储的对象更大则可以忽略不计），对CPU缓存也是不友好的。所以<strong>链表法更适用于大数据量的场景</strong>。</p> <p>链表法实际还能再优化，比如Java8中的HashMap，当链表的长度大于8时，会将链表转化为红黑树，从而将查找的时间复杂度降为 O(logn) 。</p> <h2 id="_6-java中hashmap分析"><a href="#_6-java中hashmap分析" class="header-anchor">#</a> 6. Java中HashMap分析</h2> <p>Java中的HashMap就是一个典型的工业级数据结构的实现。一个工业级的数据结构，通常要考虑以下几点：</p> <ol><li><strong>查找、删除、更新等操作的高效。</strong></li> <li><strong>对内存空间的合理占用</strong>。</li> <li><strong>性能稳定，能够应对对各种异常情况</strong>。</li></ol> <h3 id="_6-1-初始大小"><a href="#_6-1-初始大小" class="header-anchor">#</a> 6.1 初始大小</h3> <p>HashMap 默认的初始大小是 16，这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p> <p>HashMap中有很多操作为了效率都是位运算，所以这也是HashMap中的默认初始容量 16 为 2 的幂次方的原因，并且即使自己手动指定初始容量， HashMap 也会自动将其向上取值到最近的 2 的幂次方。</p> <h3 id="_6-2-装载因子和动态扩容"><a href="#_6-2-装载因子和动态扩容" class="header-anchor">#</a> 6.2 装载因子和动态扩容</h3> <p>HashMap 的负载因子为 0.75 ，是一种在性能与空间占用折衷的做法。当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p> <h3 id="_6-3-散列冲突解决方法"><a href="#_6-3-散列冲突解决方法" class="header-anchor">#</a> 6.3 散列冲突解决方法</h3> <p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p> <p>在 JDK1.8 版本中，为了对 HashMap 做进一步优化，引入了红黑树。当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p> <h3 id="_6-4-散列函数"><a href="#_6-4-散列函数" class="header-anchor">#</a> 6.4 散列函数</h3> <p>HashMap的散列函数设计并不复杂，追求的是简单高效，分布均匀：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>capicity <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//capicity表示散列表的大小</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>此处的 <code>(h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1)</code> 是一个位操作，相当于十进制中的求余操作。</p> <p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>var1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      var1 <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> var1 <span class="token operator">+</span> var2<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> var1<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> var1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_7-散列表＆链表"><a href="#_7-散列表＆链表" class="header-anchor">#</a> 7. 散列表＆链表</h2> <p>散列表经常链表一起出现，链表插入、删除操作的时间复杂度为 O(1) ，而查找操作的时间复杂度为 O(n) ，和散列表一起结合使用的时候，可以借助散列表的特性将查找操作缩短到 O(1) ，从而大大提高性能。</p> <p>之前学习链表的时候，借助链表实现了LRU缓存淘汰算法，一个缓存（cache）系统主要包含下面这几个操作：</p> <ul><li>往缓存中添加一个数据；</li> <li>从缓存中删除一个数据；</li> <li>在缓存中查找一个数据。</li></ul> <p>如果单纯使用链表来实现的话，每次更新、删除元素的时候都需要经过时间复杂度为 O(n) 的查找操作，因此这里可以结合<strong>散列表 + 链表</strong>来提高效率：</p> <p><img src="https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg" alt="散列表&amp;链表"></p> <p>在上面的数据结构图中，使用的是双向链表，但在双向链表的双向指针（<code>prev</code>、<code>next</code>）的基础上，还增加了<code>hnext</code>指针，这个 <code>hnext</code> 指针是用于散列表中的链表法的，也就是在这个数据结构中有两条链：<strong>双向链表</strong>以及<strong>散列表用来解决散列冲突的链表</strong>。</p> <p>这样一来，当我们需要查找某个元素的时候，就可以借助散列表快速定位元素，添加、删除元素则利用双向链表的的 O(1) 操作，同时由于存在双向链表，我们又可以有序遍历序列（散列表经过散列函数后顺序是打乱的）。</p> <p>实际上 Java 的 LinkedHashMap 就是这么实现的，其中的 Linked 不仅仅指使用了链表法来解决散列冲突，还指使用了双向链表来保证其有序性以及插入、删除等操作的高效性。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output:</span>
<span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>如上代码，输出的结果是按照我们添加元素的顺序输出的，就是利用了双向链表来记录其顺序。除此之外，我们来可以选择根据元素访问时间来输出：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序</span>
<span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output:</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>第二行代码中的 true 代表开启根据访问时间调整元素顺序的位置，该特性会将最近一次有访问操作（如查找、更新、插入等）的元素移动到双向链表队尾，其实这就是一个 LRU缓存淘汰算法 。</p> <h2 id="_8-redis有序集合"><a href="#_8-redis有序集合" class="header-anchor">#</a> 8. Redis有序集合</h2> <p>在跳表那一节提到了 Redis 的有序集合，一个Redis 有序集合可以细化为以下几个操作：</p> <ul><li>添加一个成员对象；</li> <li>按照键值来删除一个成员对象；</li> <li>按照键值来查找一个成员对象；</li> <li>按照分值区间查找数据，比如查找积分在 [100, 356] 之间的成员对象；</li> <li>按照分值从小到大排序成员变量；</li></ul> <p>实际上，一个有序集合会有两个属性， <strong>key</strong> （键值）和 <strong>socre</strong> （分值）。比如一个用户积分系统，一个用户有着 ID（key） 和 积分（score），假如我们根据积分来组织一个跳表，那么当我们需要根据用户 ID 来操作元素的时候，效率就会很低。</p> <p>解决思路跟前面一节一样，就是根据用户 ID 来组织一个散列表，这样一来查找、删除元素的操作就为 O(1) ，同时借助跳表的操作结构，其他操作也非常高效。</p> <p>实际上，Redis 有序集合的操作还有另外一类，也就是查找成员对象的排名（Rank）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了。这块内容后面再学习。</p> <h2 id="_9-思考"><a href="#_9-思考" class="header-anchor">#</a> 9. 思考</h2> <p><strong>Q：在散列表和链表结合使用的例子里，使用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？</strong></p> <blockquote><p>改为单链表后仍然能够正常工作，只不过当需要删除、移动中间结点的时候，需要重新从头遍历找到目标节点的前驱节点，从而导致操作的时间复杂度变为了 O(n) 。</p></blockquote> <p><strong>Q：假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</strong></p> <ul><li>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；</li> <li>查找积分在某个区间的猎头 ID 列表；</li> <li>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。</li></ul> <blockquote><ol><li>可以根据猎头 ID 建立散列表，从而可以通过 O(1) 时间复杂度定位到猎头操作其信息。</li> <li>根据猎头积分简历跳表，跳表更适合于区间查找。</li> <li>当前还无法实现。</li></ol></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/books/pages/62cbc8/" class="prev">
        11-tiao-biao
      </a></span> <span class="next"><a href="/books/pages/29a5b1/">
        13-ha-xi-suan-fa
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/books/assets/js/app.f49d838e.js" defer></script><script src="/books/assets/js/2.3809c37a.js" defer></script><script src="/books/assets/js/79.787f9e2a.js" defer></script>
  </body>
</html>
